
# JAVA 정리

<details>
<summary><strong>a_intro</strong> (JAVA - 프로그래밍 언어)</summary>

## 프로그래밍 언어
- 프로그래밍 언어는 **개발자와 운영체제가 소통하기 위한 언어**

### 소스코드
- 개발자와 운영체제가 소통할 내용을 글로 작성해 놓은 것

### 소스파일 (.java)
- 소스코드를 작성해 놓은 파일

### 컴파일
- 사람의 언어(소스코드)를 컴퓨터 언어로 변환하는 작업

### 컴파일러
- 컴파일을 수행하는 프로그램 혹은 명령어  
- 위에서 아래로, 좌에서 우로 번역

### 프로그램
- 소스코드로 잘 짜여진 틀

### 콘솔
- 개발자와 운영체제가 소통한 결과를 보여주는 창

---

## 프로그램 구조 비교

### 일반 프로그램
- **구성**: 프로그램 → OS → 하드웨어  
- **특징**
  - 이식성이 좋지 않음
  - 하드웨어에 직접 접근 가능

### JAVA 프로그램
- **구성**: JAVA 프로그램 → JVM → OS → 하드웨어  
- **특징**
  - 이식성이 좋음
  - 하드웨어에 직접 접근하기 어려움

---

## JVM, JRE, JDK

### JVM (Java Virtual Machine)
- 자바 프로그램을 실행해주는 가상 머신

### JRE (Java Runtime Environment)
- JVM을 생성하며, 실행에 필요한 라이브러리 포함

### JDK (Java Development Kit)
- 컴파일 명령어와 실행 명령어 제공  
- JRE + 개발에 필요한 도구 포함

---

## JDK 설치
[다운로드 링크](https://drive.google.com/file/d/1bsLuMXWQ-yg50m4SNToucnhEBMLSg6He/view?usp=drive_link)

### 환경 변수 설정
- 매번 해당 경로로 들어가서 실행하는 것이 불편하기 때문에 환경 변수 설정
- 설치된 프로그램을 CLI 환경에서 명령어처럼 사용하기 위해 **Path에 경로 등록**  
- 이를 통해 어디서든지 해당 명령어 실행 가능

---

## IDE (통합 개발 환경) 설치
- **이클립스** (무료, 정부 표준)  
  [다운로드 링크](https://drive.google.com/file/d/18qYUbfdkXWrX0hbSnvFOuihh9MXI_k7j/view?usp=drive_link)

- **인텔리제이** (유료, 다양한 기능)

---

## 기본 구조
기본 구조

```
프로젝트
  └── 패키지 (소문자 시작)
    └── 클래스 (대문자 시작)
      └── 메소드 (이름 + 소괄호)
        └── 소스코드
```
</details>



<details>
<summary><strong>b_print</strong> (출력 메소드)</summary>

## 출력 메소드

### 주요 출력 메소드
1. **print()**  
   - 마지막에 자동으로 줄바꿈되지 않고, 아래 문장과 이어서 출력됨

2. **println()**  
   - 마지막에 자동으로 줄바꿈됨

3. **printf()**  
   - 서식 문자를 사용하여 출력 가능  
   - 자동으로 줄바꿈되지 않음

### 출력 메소드를 사용하는 이유
- 오류를 구체적으로 확인하기 위해 개발자가 사용하는 도구

#### 예시 1: 출력 없이 코드만 작성
A 코드
B 코드
C 코드
D 코드

- 오류 발생 시 어떤 라인에서 발생했는지 알기 어렵다.

#### 예시 2: 출력 메소드 사용
```java
A 코드
System.out.println("A");
B 코드
System.out.println("B");
C 코드
System.out.println("C");
D 코드
System.out.println("D");
```

- "C"가 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에 D 코드에 문제가 발생한 것으로 판단된다.

</details>

<details>
<summary><strong>c_variable</strong> (변수와 자료형)</summary>

## 변수
- 변수는 저장공간이다.

```x = 10```

- 저장공간의 이름: x  
- 대입 연산자: =  
- 값(상수): 10

---

## 자료형(type)
- 자료형은 저장공간의 종류이다.

| 자료형 | type  | byte | 값 |
|--------|-------|------|-----------------------------|
| 정수형 | byte  | 1    | 1, 4, -120, 100 ...        |
|        | short | 2    | 123, 9, 150, -55           |
|        | int   | 4    | -2147483648 ~ 2147483647   |
|        | long  | 8    | 30L, 8L, -15464839203 ...  |
| 실수형 | float | 4    | 3.12, 2.59, -123.456, 2.0 |
|        | double| 8    | 3.12, 2.59, -123.456, 2.0 |
| 문자형 | char  | 2    | 'a', 'b', '3' ...           |
| 문자열 | String| ?    | "ABC", "0.0", "123.321", "A" ... |

---

## 변수의 선언
자료형 변수명 = 초기값;


예시:
``` int x = 10; ```

- x라는 이름의 저장공간이 int형으로 할당(allocation)되고 그 안에 10이 들어간다.

---

## 주소
``` int x = 10; ```

- x라는 이름의 저장공간이 int형으로 RAM에 할당되면, 고유한 값인 주소값이 부여된다.  
- 프로그램 실행 중 주소가 이동될 수 있으나, 중복은 없다.

---

## 변수의 사용

```
int data = 10;   // 저장공간
data = 20;     // 저장공간
data + 9;      // 값
data = data + 2;   // 저장공간 + 값
```

- 변수를 사용한 부분 전체에서 값이 참조된다.

---

## 변수 선언시 주의사항
1. 같은 이름의 변수로 선언할 수 없다.
2. 초기화를 해준다  
   - 정수: 0  
   - 실수: 0.0  
   - 문자: ' '  
   - 문자열: "", null
3. 되도록 선언부에 한꺼번에 선언 (영역 상단)

---

## 변수를 사용하는 이유
1. 반복되는 값을 쉽게 관리하기 위해서
2. 의미 없는 값을 하나의 정보로 만들기 위해서 (자료구조)

</details>


<details>
<summary><strong>d_casting</strong> (형변환)</summary>

## 형변환

### 자동 형변환
- 정수 + 정수 = 정수  
- 정수 + 실수 = 실수  
- 정수 + 문자 = 정수  

### 강제 형변환 (Casting)
- (자료형)값
- 예시:
```(double)3 == 3.0```


---

## 문자열 형변환

### 1. 다른 자료형 → 문자열
- 문자열과 다른 일반 자료형을 연결하면 결과는 **문자열**이 된다.

### 2. 문자열 → 다른 자료형
- 일반 자료형은 일반 자료형끼리만 형변환 가능  
- 문자열 타입은 **클래스 타입**으로, 일반 자료형의 클래스 타입 도움 필요

```
Integer.parseInt("") => 전달한 문자열에서 변환(추출)된 정수
Double.parseDouble("") => 전달한 문자열에서 변환(추출)된 실수
```
</details>

<details>
<summary><strong>e_constant</strong> (상수)</summary>

## 상수
- 항상 그대로인 수  
- 값은 변경할 수 없음

final 자료형 상수명 = 값;


---

## 상수를 사용하는 이유
- 값에 의미를 부여하기 위해 사용

</details>

<details>
<summary><strong>f_input</strong> (입력)</summary>

## 입력
- 커서가 깜빡이고 있는 상태를 **입력 상태**라고 한다.  
- 입력하기 전에 **출력을 통해 사용자에게 어떤 값을 입력해야 하는지 알려주어야 함**

---

## 입력 클래스
```java
Scanner sc = new Scanner(System.in);
```

- Scanner: 자료형
- sc: 변수명
- new Scanner(System.in): 값 (입력 받을 객체 생성)

---

## 입력 메소드
### next()
- 사용자가 입력한 공백 또는 줄바꿈 문자(엔터)를 구분점으로 문자열을 분리한다.
- 첫 번째 문자열은 첫 번째 next()에 담기고
- 두 번째 문자열은 두 번째 next()에 담긴다.

### nextLine()
- 사용자가 입력한 문자열 값
- 공백 문자도 값으로 취급하기 때문에 그대로 입력 받는다.

</details>

<details>
<summary><strong>g_oper</strong> (연산자와 조건식)</summary>

## 연산자
- 기능이 있는 특수문자

---

## 연산자의 우선순위
- 하나의 식에 여러 종류의 연산자가 사용될 경우, **어떤 순서로 연산되는지** 확인

1. 최우선 연산자  
2. 단항 연산자  
3. 산술 연산자  
4. 쉬프트 연산자  
5. 관계 연산자  
6. 논리 연산자  
7. 삼항 연산자  
8. 대입 연산자

---

## 결합성
- 하나의 식에 동일한 연산자가 여러 개 사용되면, **알맞는 방향으로 결합되어 연산**되는 성질

---

## 논리형 (boolean)
- 참: `true`  
- 거짓: `false`

```java
boolean check = true;
boolean check2 = 10 > 11; // false
```

- 초기값은 `false`

---

## 조건식
- 결과가 참 또는 거짓, 둘 중 하나가 나오는 식  
- 항상 **값으로 취급**

### 관계 연산자
| 연산자 | 의미       |
|--------|-----------|
| ==     | 같다      |
| !=     | 같지 않다 |
| <, >   | 미만, 초과 |
| <=, >= | 이하, 이상 |

### 논리 연산자
| 연산자 | 의미                   |
|--------|-----------------------|
| &&     | AND, 두 조건 모두 참이면 참 |
| ||     | OR, 둘 중 하나라도 참이면 참 |

### 단항 연산자
| 연산자 | 의미            |
|--------|----------------|
| !      | NOT, 참→거짓, 거짓→참 |

### 삼항 연산자
``` 조건식 ? 참 : 거짓 ```

---

## 대입 연산자 (복합 대입 연산자 / 누적 연산자)

```
int money = 10000;
// money = money - 1000
money -= 1000;
System.out.println(money);

int data = 10;
data += 1;
data++;
System.out.println(data);
```


---

## 증감 연산자
- `++`, `--`

### 전위형
- 해당 라인부터 바로 적용
```
++data;
--data;
```


### 후위형
- 다음 라인부터 적용
```
data++;
data--;
```

</details>


<details>
<summary><strong>h_control_statemaent</strong> (제어문)</summary>

## 제어문
- 컴파일러의 제어를 컨트롤 할 수 있는 문장

---

### ▶ 조건문

#### ▷ if문
```java
if(조건식){
    실행할 문장;
}
```
1. 위 조건식 결과와 상관없이 무조건 검사
```
if(조건식){
    실행할 문장;
}
if(조건식){
    실행할 문장;
}
...
if(조건식){
      실행할 문장;
}
```
   
2. 위 조건식이 false여야 검사, true라면 검사하지 않는다

```
if(조건식){
      실행할 문장;
}
else if(조건식){
      실행할 문장;
}
else if(조건식){
      실행할 문장;
}
else {
      실행할 문장;
}
...
else {
            실행할 문장;
         }
```

### ▷ switch문
```
switch(값) {
    case 값1:
        실행할 문장;
        break;
    case 값2:
        실행할 문장;
        break;
    ...
    default:
        실행할 문장;
        break;
}
```

## ※ 삼항 연산자, if, switch문의 비교
- **삼항 연산자**: 조건식을 1개만 사용할 때  
- **if문**: 조건식에 비교 연산자(>, <, <=, >=)를 사용하거나 여러 조건식을 논리 연산자로 연결할 때  
- **switch문**: 하나의 변수에 여러 경우의 값이 담길 수 있고, 각 값이 같은지 비교할 때

---

## ▶ 반복문

### ▷ for문
```java
int i = 0; i < 10; i++
for(초기식; 조건식; 증감식) {
    실행할 문장;
}
```


**for문 흐름**
1. 초기식  
2. 조건식(true)  
3. 실행할 문장  
4. 증감식  

반복:  
5. 조건식(true)  
6. 실행할 문장  
7. 증감식  

종료:  
8. 조건식(false)  
9. 반복 종료

---

### ▷ while문
```
while(조건식) {
실행할 문장;
}
```

---

### ▷ do ~ while문
```
do {
실행할 문장;
} while(조건식);
```

---

### ※ 반복문 선택 기준
- for문: 반복 횟수를 알 때  
- while문: 반복 횟수를 모를 때  
- do ~ while문: 무조건 처음 한 번은 실행해야 할 때

---

## ▶ 기타 제어문
- break: 즉시 해당 중괄호 영역을 탈출  
  - if문 안에서 사용 시, if문 자체가 아니라 감싸고 있는 중괄호 영역을 탈출  
- continue: 즉시 다음 반복으로 넘어감  
  - 아래 코드를 실행하지 않기 위해 사용

</details>

<details>
<summary><strong>i_array</strong> (배열)</summary>

## 배열을 사용하는 이유
1. 변수를 여러 개 선언하면 이름도 여러 개 생김  
   → 관리가 불편  
   → n칸 배열을 한 번만 선언하면 저장공간 n개 생성, 이름도 1개 → 관리 편함
2. 규칙성이 없는 값에 규칙성을 부여하기 위해 사용

---

## 배열 선언

```java
// 어떤 값을 넣을지 알 때
자료형[] 배열명 = {값1, 값2, ...};

// 어떤 값을 넣을지는 모르나, 칸 수를 알 때
자료형[] 배열명 = new 자료형[칸수];

// 값과 칸 수 모두 모를 때
자료형[] 배열명 = null;
```
- new: Heap 메모리에 할당, 초기값 자동 초기화

- null: 주소 초기값, 어떤 값을 넣을지 모를 때

- Java 배열은 항상 Heap(동적 메모리)에 할당 → 동적 배열만 존재

---

## 배열 구조
-int[] arData : 저장공간 1개
- 5개의 값을 담으려면 5칸 필요 → Heap 메모리에 할당
- 첫 번째 저장공간 주소가 arData에 들어감 → 다음 주소 접근은 + n
- Java에서는 주소 접근 연산자 없으므로 [] 사용

```
Data[2] // index 2 값 읽기
```

- 배열의 방 번호 → index, 항상 0부터 시작

---

## length
- 배열 선언 시 length 상수 생성 → 배열 길이 담김
- 사용: 배열명.length

---
## 배열 사용 예시
```
int[] arData = new int[5];  // 저장공간
arData[0] = 120;            // 값 할당
arData[0] + 9;              // 값 참조
System.out.println(arData); // 주소값 출력
arData[2] = arData[0] + arData[1]; // 저장공간, 값 계산
System.out.println(arData[5]);     // 오류 발생
```
---
## 2차원 배열
- 배열 안에 배열
- 1차원 배열을 여러 개 선언하면, 관리하기 어렵다.
-	2차원 배열 n행 m열을 한 번만 선언하자!
-	2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

  ---

## 2차원 배열 선언
```
// 값이 있을 때
자료형[][] 배열명 = {{값1, 값2, ...}, {값3, 값4, ...}, ...};

// 값은 모르지만 행과 열을 알 때
자료형[][] 배열명 = new 자료형[행][열];

// 값과 크기 모두 모를 때
자료형[][] 배열명 = null;
```
</details>

<details>
<summary><strong>j_method</strong> (메소드)</summary>

## 메소드
- 이름 뒤에 소괄호  
- 단, 키워드 뒤에 소괄호는 메소드가 아니다  
- 저장공간이다

예시:
```
f       (x)   =  2x + 1  
메소드  매개      리턴값  
이름     변수
```
---

## 메소드 선언
(1)리턴타입 (2)메소드명 (자료형 (3)매개변수명, ....) {  
  (4)실행할 문장  
  (5)return 리턴값;  
}  

- (1) 리턴값이 있다면 리턴값의 자료형을 작성, 없다면 void  
- (2) 동사로 작성  
- (3) 외부에서 전달받을 값이 있다면 자료형과 순서에 맞게 선언  
 - 생략 시 외부에서 값을 전달받을 수 없음  
- (4) 생략 가능, 메소드 기능을 구현하는 로직 작성  
- (5) 생략 가능, 리턴값이 있다면 사용한 부분 전체가 리턴값으로 봐야함  

---

## 메소드 선언 순서 (예제: 두 정수 덧셈)

1. 메소드 이름 결정  
 ```add(){}  ```

2. 매개변수 결정  
 ```add(int number1, int number2){}  ```

3. 실행할 문장 작성  
```
add(int number1, int number2){  
  int result = number1 + number2  
 }
```

4. 리턴값 작성  
```
 add(int number1, int number2){  
  int result = number1 + number2  
  return result;  
 }
 ```

5. 리턴타입 결정  
```
int add(int number1, int number2){  
  int result = number1 + number2  
  return result;  
 }
```

---

## 메소드 주의사항
1. 메소드를 선언할 때 `{}`가 있으며 반드시 메소드 밖에서 선언  
2. 메소드를 사용할 때 `{}`가 없으며 반드시 메소드 안에서 사용  

---

## 메소드를 사용하는 이유
1. 재사용성 (특정성을 부여하지 않음)  
2. 소스코드 간결화

</details>

<details> <summary><strong>k_class</strong> (클래스)</summary>

## 클래스(반)
- 공통 요소를 한 번만 선언해 놓고 가져다 사용하도록 설계

### 특징
1. **타입**
   - 클래스 안에 선언된 변수와 메소드를 사용하려면 해당 클래스 타입으로 변수를 선언해야 함
2. **주어**
   - 예: Monkey.eat("바나나") → 원숭이가 바나나를 먹는다
   - 항상 클래스 이름으로 시작하며, 앞글자를 대문자로 작성

---

## 클래스 선언
```
class 클래스명 {
  필드(변수, 메소드)
}
```

---

## 클래스 필드 사용
1. **객체화(instance)**
   - 객체(instance variable)을 만드는 작업, 추상적인 개념을 구체화
   - 예: ```클래스명 객체명 = new 클래스명();```
   - `.`(닷 연산자): 멤버 변수 접근, 주소값 뒤에서만 사용 가능

2. **static**
   - 모든 객체가 공유해야 하는 필드일 경우 사용
   - 클래스 하나당 한 개만 존재, 객체 없이 클래스명으로 접근

---

## 생성자
- 클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능 비슷하지만 리턴 없음
- 역할
  1. 해당 클래스의 필드를 메모리에 할당하고 주소값 부여
  2. 초기화

### 기본 생성자
- 매개변수 없는 생성자
- 클래스 선언 시 자동으로 생성
- 사용자가 직접 생성자 선언 시 기본 생성자는 사라짐

---

## this
- 필드에 접근한 객체의 주소값을 참조
- 접근한 객체의 필드 주소값이 this에 자동 저장

---

## 변수의 종류
1. **전역 변수**
   - 클래스 필드로 메소드 밖에 선언
   - 클래스 내 모든 메소드에서 접근 가능
   - 생성자를 통해 메모리에 할당, 객체마다 별도로 존재

2. **지역 변수**
   - 메소드 내부 또는 `{}` 내부에서 선언
   - 선언 영역 내에서만 사용 가능, 종료 시 사라짐
   - 반드시 초기화 필요

3. **정적 변수(static 변수)**
   - 클래스 변수라고도 함, static 키워드 사용
   - 프로그램 실행 시 가장 먼저 메모리에 할당, 단 한 번만 할당
   - 모든 객체가 공유, 객체 생성 없이 클래스명으로 접근 가능
</details>

<details> <summary><strong>l_inheritance</strong> (상속)</summary>


## 상속이 필요한 경우
1. 기존에 선언된 클래스의 필드를 새 클래스에서 그대로 사용하고자 할 때
2. 여러 클래스 선언 시 필드가 겹치면, 부모 클래스를 먼저 선언하고 공통 필드를 묶어 자식 클래스에 상속

---

## 상속 문법
```
class A {
  // A 필드
}
```
```
class B extends A {
  // A, B 필드
}
```

- A: 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
- B: 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

---

## super() - 부모 생성자
- 자식 클래스 타입의 객체는 부모 필드에 접근 가능
- 자식 생성자만 호출 시, 자식 필드만 메모리에 할당
- 실제로 자식 생성자 호출 시 부모 생성자도 호출되어 부모와 자식 필드 모두 메모리에 할당
- 부모 생성자 호출 방법: `super()`
- 코드 맨 첫 줄에 작성 필요
- super()를 생략하면 컴파일러가 자동 작성

---

## 접근 권한 제어자(Access Modifier)
1. **default**: 같은 패키지 내 접근 가능, 다른 패키지 접근 불가
2. **public**: 모든 곳에서 접근 가능, 클래스 앞에 붙이면 해당 파일의 메인 클래스 의미
3. **protected**: 다른 패키지 접근 불가, 자식 클래스 접근 가능
4. **private**: 다른 클래스에서 접근 불가

### private 사용 이유
- 외부에서 직접 필드 접근을 막고, 메소드를 통해 접근하도록 유도
- public 접근자를 통해 외부 접근 허용
- public 접근자 2가지: getter, setter
- 클래스 설계 시 변수는 private로 선언하고 getter, setter 통해 접근

---

## 단축키
- Alt + Shift + S, R : getter, setter 생성

  </details>

<details> <summary><strong>m_casting</strong> (Casting)</summary>

## 모든 자식은 부모타입이다

---

## Casting

### 1. Up Casting
- 자식 값을 부모 타입으로 형변환
- 자식에서 구현한 필드는 다른 곳에 위치하고,
  구현된 부모 필드만 들어간다

### 2. Down Casting
- 부모 타입에 자식값을 담아놓은 up casting 객체를 다시 자식 타입에 담을 수 있음
- 분리되었던 자식 필드가 다시 붙어 자식 타입에 들어감

※ 부모 값을 자식 타입으로 형변환 시 오류 발생

---

## Casting을 잘 사용하는 방법
1. 모든 자식들을 하나의 타입으로 묶을 때 **up casting** 진행
2. 전달받은 자식 객체가 어떤 타입인지 검사 후
   해당 타입으로 **down casting** 진행
- 즉, 묶어서 하나의 타입으로 받고, 다시 원래 타입으로 복구

---

## 타입 비교 연산자

### instanceof: 조건식
- 사용법: 객체명 instanceof 클래스명
1. 객체가 클래스 타입일 경우 → true
2. 객체가 클래스 타입이 아닐 경우 → false

</details>

<details> <summary><strong>n_abstract</strong> (추상 클래스)</summary>

# JAVA - 추상 클래스

## 정의
- 필드 안에 구현되지 않은 메소드가 있는 클래스를 **추상 클래스**라고 한다.
- 구현되지 않은 메소드를 **추상 메소드**라고 부른다.
- 추상 클래스는 반드시 재정의를 통해 구현해야 메모리에 할당된다.
- "강제성"을 위해 사용된다.

## 추상 클래스 선언

```
abstract class 클래스명 {
    // 추상 메소드
    abstract 리턴타입 메소드명(매개변수, ...);

    // 일반 메소드도 선언 가능
    리턴타입 메소드명(매개변수, ...) {
        // 구현 내용
    }
}
```

</details>

<details> <summary><strong>o_interface</strong> (인터페이스)</summary>


## 정의
- 추상 클래스를 고도화한 문법
- **상수**와 **추상 메소드**만 존재
- 구현은 지정한 클래스에서 진행
- 인터페이스를 클래스에 지정할 때는 **implements** 키워드 사용

## 추상 클래스와 인터페이스 관계
- 인터페이스를 클래스에 바로 지정하면 모든 메소드 구현이 강제됨
- 일반적으로 필요한 메소드만 골라서 재정의 가능
- 강제성을 없애는 중간 클래스는 **추상 클래스**로 선언
  - 추상 클래스 이름 뒤에는 `Adapter`를 붙임

## 특징
1. 인터페이스도 자료형(타입)
   - 인터페이스를 구현한 클래스는 모두 인터페이스 타입
2. 인터페이스끼리 필드 상속 시 `extends` 사용
3. **default 메소드**
   - 인터페이스 내부에서 일반 메소드 선언 가능 (JDK 8부터)
</details>

<details> <summary><strong>p_anonymous</strong> (익명 클래스)</summary>


## 내부 클래스 (Inner Class)
- 어떤 영역 안에 클래스가 선언되면 내부 클래스라고 함

## 익명 클래스 (Anonymous Inner Class)
- 이름이 없는 클래스
- 구현되지 않은 필드를 구현하기 위해 **일회성**으로 생성됨

## 실습 예시
- 나이키 회사를 설립
  - 잠실점: 일반 판매 진행
  - 강남점: 무료 나눔 행사 진행

- 지점 신규 오픈 시 본사에 **최초 1회 등록**
- 무료 나눔 행사 중:
  - "무료 나눔 행사" 출력
- 일반 판매 중:
  - 판매를 직접 수행 (`sell()` 메소드 사용)
- 무료 나눔 행사 지점은 판매 방식을 등록할 필요 없음
</details>


<details> <summary><strong>q_lambda</strong> (함수형 인터페이스 & 람다식)</summary>

## 함수형 인터페이스 (Functional Interface)
- 인터페이스 중 추상 메소드를 **하나만** 가지고 있는 인터페이스
- @FunctionalInterface를 인터페이스 위에 작성하여 **단 하나의 추상 메소드만 선언 가능**

## 람다식 (Lambda Expression)
- 함수형 인터페이스에서 **메소드 이름이 필요 없음**
- 이름 없는 메소드로서 값처럼 사용 가능
- 매개변수로 전달 가능
- 익명 메소드(Anonymous Method)라고도 부름

### 람다식 문법
1. (매개변수 형식 나열, ...) -> 리턴값;
2. (매개변수 형식 나열, ...) -> {실행할 문장; return 리턴값;};
3. 매개변수 -> 리턴값;
4. 매개변수 -> {실행할 문장; return 리턴값;};
5. 참조형 (::)
   - 생성자 참조: 클래스명::new
   - 메소드 참조
     - static, 접근 객체 메소드: 클래스명::메소드명
     - 일반: 객체명::메소드명

## [기초 실습]
- package: lambdaTask
- PrintName 인터페이스 선언
  - String getFullName(String, String) 추상 메소드 선언
  - 성과 이름 전달받음
- PrintNameTest 클래스
  - void printFullName(PrintName, String, String) 메소드
  - 외부 구현된 PrintName 전달받아 전체 이름 출력
- main 메소드에서 printFullName() 사용하여 테스트

## [심화 실습]
- 여러 개 정수 입력 후 덧셈, 뺄셈 결과 확인 애플리케이션

### 예시
- 입력: 7 + 35 - 9 → 출력: 33
- 입력: -9 + 8 + 10 → 출력: 9

### 조건
- 사용자가 정상적으로만 입력한다고 가정
- 함수형 인터페이스 Calc: 두 정수 전달받아 int 리턴
- 함수형 인터페이스 OperCheck: 전체 식 전달받아 String[] 리턴
- MyMath 클래스
  - static 메소드 operate: 두 정수 덧셈, 뺄셈 람다식 리턴
  - main 메소드에서 getOpers를 람다식으로 구현
- 첫 번째 정수가 음수일 경우 오류 해결
</details>

<details> <summary><strong>r_exception</strong> (컴파일 순서 / 예외 처리)</summary>

## 컴파일 순서
1. 디버그: 오류 검사
2. 빌드: 프로그램 생성
3. 링크: 생성된 프로그램까지의 경로를 저장
4. 실행

## 예외 처리
- 컴파일 오류: 빨간줄, 문법 오류
- 빌드 오류: 실행하자마자 오류
- 런타임 오류: 잘 실행되다가 갑자기 오류, 사용자의 입력 및 외부 요인에 의한 오류

런타임 오류는 제어문으로 막을 수 없는 경우가 있으며, 이 때 예외 처리 문법으로 해결 가능

## 예외 처리 문법
```java
try {
    // 오류가 발생할 수 있는 문장
}
 catch (예외 이름 객체명) {
    // 오류 발생 시 실행할 문장
}
catch (예외 이름 객체명) {
    // 다른 오류 발생 시 실행할 문장
}
...
finally {
    // catch에서 잡히지 않은 오류가 있더라도 무조건 실행
}
```

## 예외 발생
- 직접 예외를 발생시키려면 예외 던지기를 사용
- 생성자 호출 전 throw 키워드 사용

## 사용자 정의 예외

- 기본적으로는 예외가 아닌 특정 상황에서 직접 예외를 만들 수 있음
- Exception 혹은 RuntimeException을 상속받아 예외 클래스 선언

1. Exception은 컴파일 오류 발생 → 예외처리를 강제
2. RuntimeException은 컴파일 오류 없음 → 예외처리 선택 가능

</details>

<details> <summary><strong>s_api</strong> (API)</summary>

## API (Application Programming Interface)
개발에 필요한 라이브러리들의 집합.
선배 개발자들이 만들어 놓은 소스코드의 집합

## 내부 API
- JDK 설치 시 제공해주는 기본 API

## 외부 API
- 사설 업체에서 개발한 패키지 밑 클래스들을 의미
- 보통 JAR 파일로 배포하며, 자바 프로젝트의 Build Path에 추가해서 사용

## JAR 파일을 프로젝트에 추가하기
1. 배포된 JAR 파일을 다운 받는다
2. 프로젝트 우클릭 → Build Path → Configure Build Path
3. Libraries 탭 클릭 → ClassPath (안되면 ModulePath) 클릭 → Add External JARs
4. 저장된 경로의 `.jar` 파일 더블 클릭으로 추가
5. Apply and Close

</details>

<details> <summary><strong>t_object</strong> (Object 클래스)</summary>

최상위 부모로서, 모든 클래스는 자동으로 Object를 상속받는다.

## 1. toString()
- 항상 객체명을 출력할 때에는 toString()을 붙여서 출력
- 객체명만 출력 메소드에 전달해도 toString()의 문자열 값이 출력됨
- 기본적으로 Object에 선언된 toString()은 소속과 필드 주소를 문자열로 리턴
- 실무에서는 불필요한 정보이므로, 필드 정보를 확인하도록 재정의 후 사용
- 클래스 선언 시 각 필드의 초기화 여부를 확인할 때 활용

## 2. equals()
- 주소값을 비교하는 메소드이며 `==`과 동일
- String 클래스에서 equals()를 값 비교로 재정의
- 문자열 비교는 무조건 equals() 사용
- 원하는 필드를 비교하려면 반드시 equals()를 재정의해야 함

## 3. hashCode()
- 자바에서 사용하는 고유한 주소값
- JVM에서 관리하며 중복 없는 값, 실제 메모리 주소와 다름
- 컬렉션 프레임워크에서 재정의 목적을 이해하도록 함

</details>

<details> <summary><strong>u_collection_framework</strong> (자료구조 & 컬렉션)</summary>

## 알고리즘
어떤 문제가 발생되었을 때 해결할 수 있는 절차 혹은 순서

## 자료구조(저장공간)
의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘들의 집합.  
저장소의 종류에 대해 알아보자!

## 컬렉션 프레임워크(Collection Framework)
많은 데이터를 쉽고 효과적으로 관리할 수 있는 자료구조 클래스들의 집합

### List
List는 인터페이스이다.
1. **Vector**: 용량 관리, 보안성 강화, 처리량 감소
2. **LinkedList**: FILO로 인해 넣을 때는 빠르지만, 원하는 위치의 데이터를 가져오는 것이 상대적으로 느림
3. **ArrayList**: 인덱스로 데이터를 관리. 컬렉션 클래스 중 실무에서 가장 많이 사용됨.  
   배열의 특징인 인덱스를 이용하여 값을 저장하고 관리

**배열과 ArrayList의 차이**
- 배열: 길이에 제한이 있을 때 사용
- ArrayList: 몇 개의 데이터가 들어올지 알 수 없을 때 사용

### 실습 1
과일 정보를 담을 클래스 선언(Fruit)
- 과일 이름(중복 없음)
- 과일 가격

CRUD 관련 기능을 담아놓을 클래스 선언(Market)
- 과일 추가
- 과일 삭제
- 과일 가격이 평균 가격보다 낮은지 검사
- 과일 전체 조회
- 과일 이름으로 가격 조회

### 실습 2
음식 정보를 담을 클래스 선언(Food)
- 음식 이름
- 음식 가격
- 음식 종류(한식, 중식, 일식, 양식)

CRUD 관련 기능을 담아놓을 클래스 선언(Restaurant)
- 음식 추가
- 음식 이름으로 음식 종류 조회
- 사용자가 원하는 종류의 음식 전체 조회
- 음식 종류 수정 후 가격 10% 상승
- 사용자가 원하는 종류의 음식 개수 조회

### 숙제
직접 주제를 정한 뒤 CRUD 연습하기.  
총 3가지의 주제로 구성하고 구현

### Set(집합)
Set은 인터페이스이다.  
List와 마찬가지로 Collection 인터페이스를 상속받음

**HashSet**
- 집합에서 중복되는 원소를 포함할 수 없는 것처럼, 중복되는 값을 무시
- 저장된 값들은 인덱스가 없기 때문에 순서 없음
- 값의 유무 검사에 특화, 해시코드 기반으로 유무 검사 → 속도가 상대적으로 좋음

**Iterator**
- 순서가 없는 객체에 순서를 부여하거나, 순서가 있어도 Iterator 방식의 순서로 변경
- 해당 객체에 `iterator()` 메소드 사용, 리턴 타입은 Iterator
- `hasNext()`로 다음 값 존재 여부 검사, `next()`로 값 가져오기

### Map
Set과 Collection 2개의 자료구조를 하나로 합친 자료구조  
List와 Set처럼 Collection 상속하지 않고 독립적

**HashMap** (서버 간 데이터 전달)
- Key와 Value 한 쌍으로 저장, 검색 목적
- Key에 중복 값 넣으면 Value가 최근 값으로 수정
- Key가 중복되지 않으면 새롭게 추가
- Value는 중복 가능

</details>

<details> <summary><strong>v_thread</strong> (멀티쓰레드 & 문자열)</summary>

## 프로그램, 프로세스, 쓰레드

- **프로그램**: 실행이 안 된 상태
- **프로세스**: 실행 중인 프로그램
- **쓰레드**: 프로세스 내의 작업 처리 경로

### 쓰레드 유형
- **싱글 쓰레드 (단일 쓰레드)**
  - 처리 경로가 하나이므로 직렬적 처리
  - 하나의 작업 문제 발생 시 다른 작업에는 영향 없음 → 안정성 보장
  - 설계가 단순

- **멀티 쓰레드 (다중 쓰레드)**
  - 한 프로세스를 동시에 처리하는 것처럼 보이나, 실제는 짧은 단위로 분할 후 처리
  - 여러 처리 경로 존재 → 동시 작업 가능
  - 하나의 쓰레드 문제 발생 시 전체에 영향
  - 장점: 처리량, 효율성, 생산성 증가

---

# 멀티 쓰레드 구현 방법
**핵심: run() 메소드 재정의**

1. **Thread 클래스 상속**
   - run() 재정의
   - start()로 스케줄링

2. **Runnable 인터페이스 구현**
   - run() 구현
   - Thread 생성자에 전달 후 start() 호출

> 주의: extends는 한 번만 사용 가능 → Runnable 구현 선호  
> Runnable은 함수형 인터페이스 → 람다로 구현 가능

---

# 동기화(Synchronized)
- 하나의 쓰레드가 자원 접근 중일 때 다른 쓰레드 접근 차단
- 자원 공유 문제 방지

**동기화 문법**
- **블록**
```java
synchronized(mutex){
   ...
}
```
- 영역 전체에 동기화 걸린다.
- mutex는 문이고, 이 문에 들어오는 쓰레드는 lock 상태에 돌입한다.
- 해당 자원을 모두 사용하면(코드 모두 실행 후) lock을 해제하고 다음 쓰레드가 들어온다.


- **키워드**

  synchronized
 - 메소드 리턴 타입 앞에 작성하면, 해당 메소드가 전체 동기화에 걸린다.

# String
- 새로운 문자열 상수를 대입할 때마다, 동일한 문자열이 없다면 Constant Pool에 객체가 생성됨
- `+` 연산으로 문자열을 반복 연결 시 객체 다수 생성 → 메모리 비용 증가

# StringBuilder
- 하나의 객체를 생성 후 append()로 문자열 연결
- 객체 반복 생성 없음 → 메모리 효율 ↑
- 완성된 문자열 확인: `toString()`

# StringBuffer
- StringBuilder와 동일하게 하나의 객체로 문자열 연결
- 내부 동기화 포함 → 단일 쓰레드에서는 속도 ↓
- 멀티 쓰레드 환경에서 안전하게 사용 가능
- JDK 5 이전 코드 호환 위해 존재, 오래된 라이브러리에서 여전히 사용 가능

</details>
