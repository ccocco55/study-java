
# JAVA 정리

<details>
<summary><strong>a_intro</strong> (JAVA - 프로그래밍 언어)</summary>

## 프로그래밍 언어
- 프로그래밍 언어는 **개발자와 운영체제가 소통하기 위한 언어**

### 소스코드
- 개발자와 운영체제가 소통할 내용을 글로 작성해 놓은 것

### 소스파일 (.java)
- 소스코드를 작성해 놓은 파일

### 컴파일
- 사람의 언어(소스코드)를 컴퓨터 언어로 변환하는 작업

### 컴파일러
- 컴파일을 수행하는 프로그램 혹은 명령어  
- 위에서 아래로, 좌에서 우로 번역

### 프로그램
- 소스코드로 잘 짜여진 틀

### 콘솔
- 개발자와 운영체제가 소통한 결과를 보여주는 창

---

## 프로그램 구조 비교

### 일반 프로그램
- **구성**: 프로그램 → OS → 하드웨어  
- **특징**
  - 이식성이 좋지 않음
  - 하드웨어에 직접 접근 가능

### JAVA 프로그램
- **구성**: JAVA 프로그램 → JVM → OS → 하드웨어  
- **특징**
  - 이식성이 좋음
  - 하드웨어에 직접 접근하기 어려움

---

## JVM, JRE, JDK

### JVM (Java Virtual Machine)
- 자바 프로그램을 실행해주는 가상 머신

### JRE (Java Runtime Environment)
- JVM을 생성하며, 실행에 필요한 라이브러리 포함

### JDK (Java Development Kit)
- 컴파일 명령어와 실행 명령어 제공  
- JRE + 개발에 필요한 도구 포함

---

## JDK 설치
[다운로드 링크](https://drive.google.com/file/d/1bsLuMXWQ-yg50m4SNToucnhEBMLSg6He/view?usp=drive_link)

### 환경 변수 설정
- 매번 해당 경로로 들어가서 실행하는 것이 불편하기 때문에 환경 변수 설정
- 설치된 프로그램을 CLI 환경에서 명령어처럼 사용하기 위해 **Path에 경로 등록**  
- 이를 통해 어디서든지 해당 명령어 실행 가능

---

## IDE (통합 개발 환경) 설치
- **이클립스** (무료, 정부 표준)  
  [다운로드 링크](https://drive.google.com/file/d/18qYUbfdkXWrX0hbSnvFOuihh9MXI_k7j/view?usp=drive_link)

- **인텔리제이** (유료, 다양한 기능)

---

## 기본 구조
기본 구조

```
프로젝트
  └── 패키지 (소문자 시작)
    └── 클래스 (대문자 시작)
      └── 메소드 (이름 + 소괄호)
        └── 소스코드
```
</details>



<details>
<summary><strong>b_print</strong> (출력 메소드)</summary>

## 출력 메소드

### 주요 출력 메소드
1. **print()**  
   - 마지막에 자동으로 줄바꿈되지 않고, 아래 문장과 이어서 출력됨

2. **println()**  
   - 마지막에 자동으로 줄바꿈됨

3. **printf()**  
   - 서식 문자를 사용하여 출력 가능  
   - 자동으로 줄바꿈되지 않음

### 출력 메소드를 사용하는 이유
- 오류를 구체적으로 확인하기 위해 개발자가 사용하는 도구

#### 예시 1: 출력 없이 코드만 작성
A 코드
B 코드
C 코드
D 코드

- 오류 발생 시 어떤 라인에서 발생했는지 알기 어렵다.

#### 예시 2: 출력 메소드 사용
```java
A 코드
System.out.println("A");
B 코드
System.out.println("B");
C 코드
System.out.println("C");
D 코드
System.out.println("D");
```

- "C"가 콘솔에 출력되었다면, 위에서 아래로 번역되기 때문에 D 코드에 문제가 발생한 것으로 판단된다.

</details>

<details>
<summary><strong>c_variable</strong> (변수와 자료형)</summary>

## 변수
- 변수는 저장공간이다.

```x = 10```

- 저장공간의 이름: x  
- 대입 연산자: =  
- 값(상수): 10

---

## 자료형(type)
- 자료형은 저장공간의 종류이다.

| 자료형 | type  | byte | 값 |
|--------|-------|------|-----------------------------|
| 정수형 | byte  | 1    | 1, 4, -120, 100 ...        |
|        | short | 2    | 123, 9, 150, -55           |
|        | int   | 4    | -2147483648 ~ 2147483647   |
|        | long  | 8    | 30L, 8L, -15464839203 ...  |
| 실수형 | float | 4    | 3.12, 2.59, -123.456, 2.0 |
|        | double| 8    | 3.12, 2.59, -123.456, 2.0 |
| 문자형 | char  | 2    | 'a', 'b', '3' ...           |
| 문자열 | String| ?    | "ABC", "0.0", "123.321", "A" ... |

---

## 변수의 선언
자료형 변수명 = 초기값;


예시:
``` int x = 10; ```

- x라는 이름의 저장공간이 int형으로 할당(allocation)되고 그 안에 10이 들어간다.

---

## 주소
``` int x = 10; ```

- x라는 이름의 저장공간이 int형으로 RAM에 할당되면, 고유한 값인 주소값이 부여된다.  
- 프로그램 실행 중 주소가 이동될 수 있으나, 중복은 없다.

---

## 변수의 사용

```
int data = 10;   // 저장공간
data = 20;     // 저장공간
data + 9;      // 값
data = data + 2;   // 저장공간 + 값
```

- 변수를 사용한 부분 전체에서 값이 참조된다.

---

## 변수 선언시 주의사항
1. 같은 이름의 변수로 선언할 수 없다.
2. 초기화를 해준다  
   - 정수: 0  
   - 실수: 0.0  
   - 문자: ' '  
   - 문자열: "", null
3. 되도록 선언부에 한꺼번에 선언 (영역 상단)

---

## 변수를 사용하는 이유
1. 반복되는 값을 쉽게 관리하기 위해서
2. 의미 없는 값을 하나의 정보로 만들기 위해서 (자료구조)

</details>


<details>
<summary><strong>d_casting</strong> (형변환)</summary>

## 형변환

### 자동 형변환
- 정수 + 정수 = 정수  
- 정수 + 실수 = 실수  
- 정수 + 문자 = 정수  

### 강제 형변환 (Casting)
- (자료형)값
- 예시:
```(double)3 == 3.0```


---

## 문자열 형변환

### 1. 다른 자료형 → 문자열
- 문자열과 다른 일반 자료형을 연결하면 결과는 **문자열**이 된다.

### 2. 문자열 → 다른 자료형
- 일반 자료형은 일반 자료형끼리만 형변환 가능  
- 문자열 타입은 **클래스 타입**으로, 일반 자료형의 클래스 타입 도움 필요

```
Integer.parseInt("") => 전달한 문자열에서 변환(추출)된 정수
Double.parseDouble("") => 전달한 문자열에서 변환(추출)된 실수
```
</details>

<details>
<summary><strong>e_constant</strong> (상수)</summary>

## 상수
- 항상 그대로인 수  
- 값은 변경할 수 없음

final 자료형 상수명 = 값;


---

## 상수를 사용하는 이유
- 값에 의미를 부여하기 위해 사용

</details>

<details>
<summary><strong>f_input</strong> (입력)</summary>

## 입력
- 커서가 깜빡이고 있는 상태를 **입력 상태**라고 한다.  
- 입력하기 전에 **출력을 통해 사용자에게 어떤 값을 입력해야 하는지 알려주어야 함**

---

## 입력 클래스
```java
Scanner sc = new Scanner(System.in);
```

- Scanner: 자료형
- sc: 변수명
- new Scanner(System.in): 값 (입력 받을 객체 생성)

---

## 입력 메소드
### next()
- 사용자가 입력한 공백 또는 줄바꿈 문자(엔터)를 구분점으로 문자열을 분리한다.
- 첫 번째 문자열은 첫 번째 next()에 담기고
- 두 번째 문자열은 두 번째 next()에 담긴다.

### nextLine()
- 사용자가 입력한 문자열 값
- 공백 문자도 값으로 취급하기 때문에 그대로 입력 받는다.

</details>

<details>
<summary><strong>g_operator</strong> (연산자와 조건식)</summary>

## 연산자
- 기능이 있는 특수문자

---

## 연산자의 우선순위
- 하나의 식에 여러 종류의 연산자가 사용될 경우, **어떤 순서로 연산되는지** 확인

1. 최우선 연산자  
2. 단항 연산자  
3. 산술 연산자  
4. 쉬프트 연산자  
5. 관계 연산자  
6. 논리 연산자  
7. 삼항 연산자  
8. 대입 연산자

---

## 결합성
- 하나의 식에 동일한 연산자가 여러 개 사용되면, **알맞는 방향으로 결합되어 연산**되는 성질

---

## 논리형 (boolean)
- 참: `true`  
- 거짓: `false`

```java
boolean check = true;
boolean check2 = 10 > 11; // false
```

- 초기값은 `false`

---

## 조건식
- 결과가 참 또는 거짓, 둘 중 하나가 나오는 식  
- 항상 **값으로 취급**

### 관계 연산자
| 연산자 | 의미       |
|--------|-----------|
| ==     | 같다      |
| !=     | 같지 않다 |
| <, >   | 미만, 초과 |
| <=, >= | 이하, 이상 |

### 논리 연산자
| 연산자 | 의미                   |
|--------|-----------------------|
| &&     | AND, 두 조건 모두 참이면 참 |
| ||     | OR, 둘 중 하나라도 참이면 참 |

### 단항 연산자
| 연산자 | 의미            |
|--------|----------------|
| !      | NOT, 참→거짓, 거짓→참 |

### 삼항 연산자
``` 조건식 ? 참 : 거짓 ```

---

## 대입 연산자 (복합 대입 연산자 / 누적 연산자)

```
int money = 10000;
// money = money - 1000
money -= 1000;
System.out.println(money);

int data = 10;
data += 1;
data++;
System.out.println(data);
```


---

## 증감 연산자
- `++`, `--`

### 전위형
- 해당 라인부터 바로 적용
```
++data;
--data;
```


### 후위형
- 다음 라인부터 적용
```
data++;
data--;
```

</details>


<details>
<summary><strong>h_control</strong> (제어문)</summary>

## 제어문
- 컴파일러의 제어를 컨트롤 할 수 있는 문장

---

### ▶ 조건문

#### ▷ if문
```java
if(조건식){
    실행할 문장;
}
```
1. 위 조건식 결과와 상관없이 무조건 검사
```
if(조건식){
    실행할 문장;
}
if(조건식){
    실행할 문장;
}
...
if(조건식){
      실행할 문장;
}
```
   
2. 위 조건식이 false여야 검사, true라면 검사하지 않는다

```
if(조건식){
      실행할 문장;
}
else if(조건식){
      실행할 문장;
}
else if(조건식){
      실행할 문장;
}
else {
      실행할 문장;
}
...
else {
            실행할 문장;
         }
```

### ▷ switch문
```
switch(값) {
    case 값1:
        실행할 문장;
        break;
    case 값2:
        실행할 문장;
        break;
    ...
    default:
        실행할 문장;
        break;
}
```
